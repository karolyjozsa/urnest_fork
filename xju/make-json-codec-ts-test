#!/bin/env python3

import re
from typing import Literal, Self
from types import NoneType
from ipaddress import IPv4Address,IPv4Interface
from xju.json_codec import codec, TypeScriptNamespace, TypeScriptSourceCode, TypeScriptNamespace
from xju.json_codec import TypeScriptUQN, AnyJsonCodecImpl, encode_attr_as, PythonAttrName, JsonAttrName
from xju.json_codec import SelfCodecImpl,JsonType,TypeScriptBackRefs
from xju.json_codec import CustomNonStringKeyClassCodec,CustomClassCodec,CustomStringKeyClassCodec
from xju.misc import ByteCount
from xju.newtype import Str
from xju.time import Duration, Timestamp
from xju.assert_ import Assert
from xju.xn import readable_repr
from dataclasses import dataclass
from enum import Enum

namespace=TypeScriptNamespace({})

def indent(n: int, s:TypeScriptSourceCode)->str:
    lines=s.splitlines()
    return '\n'.join([lines[0].value()]+[(' '*n)+l.value() for l in lines[1:]])

ten_codec=codec(dict[Literal[10]|Literal[True],int])

class SurnameTag:pass
class Surname(Str[SurnameTag]):
    pattern=re.compile(r'^\S*$')  # disallow whitespace
    pass

surname_codec=codec(Surname)
surname_codec.ensure_typescript_defs(namespace)

class O(Enum):
    a='fred'
    b='jock'
    pass
o_codec=codec(O)
o_codec.ensure_typescript_defs(namespace)

class Pnum(Enum):
    a='aa'
    b='bb'
    pass
pnum_codec=codec(Pnum)
pnum_codec.ensure_typescript_defs(namespace)


@dataclass
class FullName:
    first_name: str
    middle_names: list[str]
    last_name: str
    _class: Literal["Upper", "Middle", "Lower"]
    pass

encode_attr_as(FullName, PythonAttrName("_class"), JsonAttrName("class"))

@dataclass
class Prefs:
    colours: set[str]
    pass

timestamp_codec=codec(Timestamp)
timestamp_codec.ensure_typescript_defs(namespace)
bytecount_codec=codec(ByteCount)
bytecount_codec.ensure_typescript_defs(namespace)
typescript_uqn_codec=codec(TypeScriptUQN)
typescript_uqn_codec.ensure_typescript_defs(namespace)
typescript_source_code_codec=codec(TypeScriptSourceCode)
typescript_source_code_codec.ensure_typescript_defs(namespace)
duration_codec=codec(Duration)
duration_codec.ensure_typescript_defs(namespace)
namespace_codec=codec(TypeScriptNamespace)
namespace_codec.ensure_typescript_defs(namespace)
enum_codec=codec(O)
enum_codec.ensure_typescript_defs(namespace)
codec(FullName).ensure_typescript_defs(namespace)
codec(Prefs).ensure_typescript_defs(namespace)

codec(int|str).add_typescript_alias(namespace, [TypeScriptUQN('xju'),TypeScriptUQN('NorS')])
class NonStringKey:
    values: dict[TypeScriptUQN, int]
    pass

codec(NonStringKey).ensure_typescript_defs(namespace)

# ... custom class encoding by implementing CustomClassCodec protocol, for example
# to support encoding of external types with control over their json representation
# ... to be usable as a dictionary key, the class also has to implement either
# the CustomStringKeyClassCodec or CustomNonStringKeyClassCodec
class IpV4Addr(IPv4Address):
    __xju_json_codec=codec(int)

    # xju.json_codec.CustomClassCodec:
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4Addr)
        return IpV4Addr.__xju_json_codec.encode(int(x))
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4Addr(IpV4Addr.__xju_json_codec.decode(x))
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return IpV4Addr.__xju_json_codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('int /* IpV4Addr */')
    @staticmethod
    def xju_json_codec_get_typescript_isa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return IpV4Addr.__xju_json_codec.get_typescript_isa(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return IpV4Addr.__xju_json_codec.get_typescript_asa(expression,namespace)

    # xju.json_codec.CustomNonStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return {
            'description': "stringified-int IpV4Addr",
            'type': 'string',
            'pattern': r'^(0|[1-9][0-9]*)$'
        }

    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['NonString']:
        return 'NonString'
    
    @staticmethod
    def xju_json_codec_get_typescript_isa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: should validate the int value 0<=v<2^32
        return IpV4Addr.__xju_json_codec.get_typescript_isa_key(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: should validate the int value 0<=v<2^32
        return IpV4Addr.__xju_json_codec.get_typescript_asa_key(expression,namespace)
    pass

Assert(IpV4Addr).isSubclassOf(CustomClassCodec)
Assert(IpV4Addr).isSubclassOf(CustomNonStringKeyClassCodec)

@dataclass
class IpV4AddrWithPrefix(IPv4Interface):
    """An IP host address in a network, e.g. 10.1.1.49/24"""
    if_str: str
    __codec=codec(str)
    def __post_init__(self):
        super().__init__(self.if_str)
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4AddrWithPrefix(IpV4AddrWithPrefix.__codec.decode(x))
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4AddrWithPrefix)
        return IpV4AddrWithPrefix.__codec.encode(x.if_str)
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.__codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('string /* IpV4AddrWithPrefix */')
    @staticmethod
    def xju_json_codec_get_typescript_isa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return IpV4AddrWithPrefix.__codec.get_typescript_isa(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return IpV4AddrWithPrefix.__codec.get_typescript_asa(expression,namespace)

    # xju.json_codec.CustomStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.xju_json_codec_get_json_schema(definitions)
    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['String']:
        return 'String'
    @staticmethod
    def xju_json_codec_get_typescript_isa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: tighten to use regex and test
        return IpV4AddrWithPrefix.__codec.get_typescript_isa_key(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: tighten to use regex and test
        return IpV4AddrWithPrefix.__codec.get_typescript_asa(expression,namespace)
    pass

Assert(IpV4AddrWithPrefix).isSubclassOf(CustomClassCodec)
Assert(IpV4AddrWithPrefix).isSubclassOf(CustomStringKeyClassCodec)


print(namespace.get_formatted_defs())

print(f'''\
function str(x:any):string {{ return `${{x}}`; }}
function isObject(x:any):x is object {{ return typeof(x) === 'object'; }}
function assert_equal<T>(x:T, y:T){{
    if (Array.isArray(x) && Array.isArray(y)){{
        assert_arrays_equal<any>(x,y);
    }}
    else if (isObject(x) && isObject(y)){{
        assert_objects_equal(x,y);
    }}
    else if (!(x==y)){{
        throw new Error(`${{format_(x)}} != ${{format_(y)}}`);
    }}
}}
function format_<T>(a:T): string {{
    if (Array.isArray(a)) return format_array(a);
    if (isObject(a)) return format_object(a);
    return JSON.stringify(a);
}}
function format_array<T>(a:Array<T>): string {{
    if(a.length==0) return "[]";
    if(a.length==1) return `[${{format_(a[0])}}]`;
    var result=`${{a[0]}}`;
    for(var i=1;i!=a.length;++i) result=result+`,${{format_(a[i])}}`;
    return `[${{result}}]`;
}}
function format_object<T>(a:T): string {{
    var result="{{";
    for(const k in a) result=result+` ${{k}}:${{format_(a[k])}};`;
    return result+"}}";
}}
function assert_arrays_equal<T>(x:Array<T>, y:Array<T>){{
    try{{
        try{{
            assert_equal(x.length, y.length);
        }}
        catch(e:any){{
            throw new Error(`arrays of different length because ${{e}}`);
        }}
        var i;
        for(i=0; i!=x.length; ++i){{
            try{{
                assert_equal<T>(x[i],y[i]);
            }}
            catch(e:any){{
                throw new Error(`array element ${{i}} ${{format_(x[i])}} != ${{format_(y[i])}}`);
            }}
        }}
    }}
    catch(e:any){{
        throw new Error(`array ${{format_(x)}} != array ${{format_(y)}} because ${{e}}`);
    }}
}}
function assert_objects_equal(x:object, y:object){{
    try{{
        var xKeys=new Array<keyof object>();
        var yKeys=new Array<keyof object>();
        for(const k in x){{if (x.hasOwnProperty(k)) xKeys.push(k as keyof object);}}
        for(const k in y){{if (y.hasOwnProperty(k)) yKeys.push(k as keyof object);}}
        assert_arrays_equal(xKeys,yKeys);
        for(var i=0; i!=xKeys.length; ++i){{
            const k = xKeys[i];
            assert_equal(x[k],y[k]);
        }}
    }}
    catch(e){{
        throw new Error(`object ${{format_(x)}} != object ${{format_(y)}} because ${{e}}`);
    }}
}}
function assert_x_contains_y(x:string, y:string){{
    if (x.indexOf(y)==-1){{
        throw new Error(`"${{x}}" does not contain "${{y}}"`)
    }}
}}
function assert_true(x:boolean){{
    if (!x){{
        throw new Error(`"${{x}}" is false, expected true`);
    }}
}}
function assert_false(x:boolean){{
    if (x){{
        throw new Error(`"${{x}}" is true, expected false`);
    }}
}}
function assert_never_reached(){{
   throw new Error(`should not be here`);
}}
//number
(() => {{
    assert_equal({indent(4,codec(int).get_typescript_asa(TypeScriptSourceCode('5'),namespace))}, 5);
    assert_equal({indent(4,codec(int).get_typescript_asa(TypeScriptSourceCode('5.5'),namespace))}, 5.5);
    try{{
        {indent(8,codec(int).get_typescript_asa(TypeScriptSourceCode('"fred"'),namespace))};
        throw new Error("should not be here");
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: fred is not a number it is a string");
    }}
    assert_true({codec(int).get_typescript_isa(TypeScriptSourceCode('5'),namespace)});
    assert_true({codec(int).get_typescript_isa(TypeScriptSourceCode('5.5'),namespace)});
    assert_false({codec(int).get_typescript_isa(TypeScriptSourceCode('"fred"'),namespace)});
}})();
//string
(() => {{
    assert_equal({indent(4,codec(str).get_typescript_asa(TypeScriptSourceCode('"ann"'),namespace))}, 'ann');
    try{{
        {indent(8,codec(str).get_typescript_asa(TypeScriptSourceCode('7'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7 is not a string it is a number");
    }}
    assert_true({codec(str).get_typescript_isa(TypeScriptSourceCode('"ann"'),namespace)});
    assert_false({codec(str).get_typescript_isa(TypeScriptSourceCode('7'),namespace)});
}})();
//boolean
(() => {{
    assert_equal({indent(4,codec(bool).get_typescript_asa(TypeScriptSourceCode('true'),namespace))}, true);
    try{{
        {indent(8,codec(bool).get_typescript_asa(TypeScriptSourceCode('7'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7 is not a boolean it is a number");
    }}
    assert_true({codec(bool).get_typescript_isa(TypeScriptSourceCode('true'),namespace)});
    assert_false({codec(bool).get_typescript_isa(TypeScriptSourceCode('7'),namespace)});
}})();
//null
(() => {{
    assert_equal({indent(4,codec(NoneType).get_typescript_asa(TypeScriptSourceCode('null'),namespace))}, null);
    try{{
        {indent(8,codec(NoneType).get_typescript_asa(TypeScriptSourceCode('7'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7 is not null it is a number");
    }}
    assert_true({codec(NoneType).get_typescript_isa(TypeScriptSourceCode('null'),namespace)});
    assert_false({codec(NoneType).get_typescript_isa(TypeScriptSourceCode('7'),namespace)});
}})();
//Array<T>
(() => {{
    assert_equal({indent(4,codec(list[int]).get_typescript_asa(TypeScriptSourceCode('[7, 8]'),namespace))}, [7, 8]);
    try{{
        {indent(8,codec(list[int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a Array<number> because Error: ann is not a number it is a string");
    }}
    assert_true({codec(list[int]).get_typescript_isa(TypeScriptSourceCode('[7, 8]'),namespace)});
    assert_false({codec(list[int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
//Set<T>
(() => {{
    assert_equal({indent(4,codec(set[int]).get_typescript_asa(TypeScriptSourceCode('[7, 8]'),namespace))}, [7, 8]);
    try{{
        {indent(8,codec(set[int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a Array<number> /* with unique elements */ because Error: ann is not a number it is a string");
    }}
}})();
//Set<any>
(() => {{
    assert_equal({indent(4,codec(set).get_typescript_asa(TypeScriptSourceCode('[7, "ann"]'),namespace))}, [7, "ann"]);
    try{{
        {indent(8,codec(set).get_typescript_asa(TypeScriptSourceCode('22'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 22 is not an Array<any> /* with unique elements */ it is a number");
    }}
}})();
//bytes
(() => {{
    assert_equal({indent(4,codec(bytes).get_typescript_asa(TypeScriptSourceCode('[7, 8]'),namespace))}, [7, 8]);
    try{{
        {indent(8,codec(bytes).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a Array<number> because Error: ann is not a number it is a string");
    }}
    assert_equal('{codec(bytes).typescript_type()}',"Array<number> /* bytes */");
    assert_true({codec(bytes).get_typescript_isa(TypeScriptSourceCode('[7, 8]'),namespace)});
    assert_false({codec(bytes).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
//Array i.e. Array<any>
(() => {{
    assert_equal({indent(4,codec(list).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))}, [7, "ann"]);
    try{{
        {indent(8,codec(list).get_typescript_asa(TypeScriptSourceCode('7'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7 is not an Array it is a number");
    }}
    assert_true({codec(list).get_typescript_isa(TypeScriptSourceCode('[7,"ann"]'),namespace)});
    assert_false({codec(list).get_typescript_isa(TypeScriptSourceCode('7'),namespace)});
}})();
//tuple
(() => {{
    assert_equal({indent(4,codec(tuple[int,str]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))}, [7, "ann"]);
    try{{
        {indent(8,codec(tuple[int,str]).get_typescript_asa(TypeScriptSourceCode('7'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7 is not a [number,string] because Error: 7 is not an array it is a number");
    }}
    try{{
        {indent(8,codec(tuple[int,str]).get_typescript_asa(TypeScriptSourceCode('[7, 8]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,8 is not a [number,string] because Error: 8 is not a string it is a number");
    }}
    try{{
        {indent(8,codec(tuple[int,str]).get_typescript_asa(TypeScriptSourceCode('[7, "ann", 8]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann,8 is not a [number,string] because Error: 7,ann,8 does not have 2 elements (it has 3 elements)");
    }}
    assert_true({codec(tuple[int,str]).get_typescript_isa(TypeScriptSourceCode('[7,"ann"]'),namespace)});
    assert_false({codec(tuple[int,str]).get_typescript_isa(TypeScriptSourceCode('7'),namespace)});
}})();
''')
print(f'''//union\n'''+
      f'''(() => {{\n'''+
      f'''    assert_equal({indent(4,codec(int|str).get_typescript_asa(TypeScriptSourceCode('7'),namespace))}, 7);\n'''+
      f'''    assert_equal({indent(4,codec(int|str).get_typescript_asa(TypeScriptSourceCode('"ann"'),namespace))}, "ann");\n'''+
      f'''    try{{\n'''+
      f'''        {indent(8,codec(int|str).get_typescript_asa(TypeScriptSourceCode('true'),namespace))};\n'''+
      f'''        assert_never_reached();\n'''+
      f'''    }}\n'''+
      f'''    catch(e){{\n'''+
      f'''        assert_x_contains_y(str(e), "Error: true is not a number|string because Error: true is not a number it is a boolean and true is not a string it is a boolean");\n'''+
      f'''    }}\n'''+
      f'''    try{{\n'''+
      f'''        {indent(8,codec(int|str).get_typescript_asa(TypeScriptSourceCode('[7, 8]'),namespace))};\n'''+
      f'''        assert_never_reached();\n'''+
      f'''    }}\n'''+
      f'''    catch(e){{\n'''+
      f'''        assert_x_contains_y(str(e), "Error: 7,8 is not a number|string because Error: 7,8 is not a number it is a object and 7,8 is not a string it is a object");\n'''+
      f'''    }}\n'''+
      f'''    assert_true({codec(int|str).get_typescript_isa(TypeScriptSourceCode('7'),namespace)});\n'''+
      f'''    assert_true({codec(int|str).get_typescript_isa(TypeScriptSourceCode('"ann"'),namespace)});\n'''+
      f'''    assert_false({codec(int|str).get_typescript_isa(TypeScriptSourceCode('false'),namespace)});\n'''+
      f'''    assert_false({codec(int|str).get_typescript_isa(TypeScriptSourceCode('[7,"ann"]'),namespace)});\n'''+
      f'''}})();

''')
print(f'''
//dict[str,T]
(() => {{
    assert_equal({indent(8,codec(dict[str,int]).get_typescript_asa(TypeScriptSourceCode('{"fred": 8}'),namespace))}, {{"fred": 8}});
    try{{
        {indent(8,codec(dict[str,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[str,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[str,int]).get_typescript_asa(TypeScriptSourceCode('{"a":8, "ann": "fred"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string]: number }} because Error: element ann is invalid because Error: fred is not a number it is a string");
    }}
    assert_true({indent(8,codec(dict[str,int]).get_typescript_isa(TypeScriptSourceCode('{"fred": 8}'),namespace))});
    assert_false({indent(8,codec(dict[str,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[str,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}})();
''')

print(f'''
//dict[int,T]
(() => {{
    assert_equal({indent(8,codec(dict[int,int]).get_typescript_asa(TypeScriptSourceCode('{"1": 8}'),namespace))}, {{"1": 8}});
    try{{
        {indent(8,codec(dict[int,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* int */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[int,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* int */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[int,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "2": "fred"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* int */]: number }} because Error: element 2 is invalid because Error: fred is not a number it is a string");
    }}
    try{{
        {indent(8,codec(dict[int,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "ann": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* int */]: number }} because Error: element ann is invalid because Error: ann is not a stringified integer");
    }}

    assert_true({indent(8,codec(dict[int,int]).get_typescript_isa(TypeScriptSourceCode('{"1": 8}'),namespace))});
    assert_false({indent(8,codec(dict[int,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[int,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}})();
''')

print(f'''
//dict[None|ByteCount|float|bool,T]
(() => {{
    assert_equal({indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1": 8, "true": 9, "null": 10, "99": 98}'),namespace))}, {{"1": 8, "true":9, "null": 10, "99": 98}});
    try{{
        {indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* string ** null **|string ** xju.misc.ByteCount **|string ** float **|string ** bool ** */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* string ** null **|string ** xju.misc.ByteCount **|string ** float **|string ** bool ** */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "2": "fred"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* string ** null **|string ** xju.misc.ByteCount **|string ** float **|string ** bool ** */]: number }} because Error: element 2 is invalid because Error: fred is not a number it is a string");
    }}
    try{{
        {indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "ann": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* string ** null **|string ** xju.misc.ByteCount **|string ** float **|string ** bool ** */]: number }} because Error: element ann is invalid because Error: ann is not a string /* string ** null **|string ** xju.misc.ByteCount **|string ** float **|string ** bool ** */ because Error: key ann is not 'null' and key ann is not a stringified integer and ann is not a stringified number and ann is not 'true' or 'false'");
    }}

    assert_true({indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_isa(TypeScriptSourceCode('{"1": 8, "true": 9, "null": 10}'),namespace))});
    assert_false({indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[None|ByteCount|float|bool,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}})();
''')


print(f'''
//dict[Duration|bool,T]
(() => {{
    assert_equal({indent(8,codec(dict[Duration|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1.2": 8, "true": 9}'),namespace))}, {{"1.2": 8, "true":9}});
    try{{
        {indent(8,codec(dict[Duration|bool,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* string ** xju.time.Duration **|string ** bool ** */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[Duration|bool,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* string ** xju.time.Duration **|string ** bool ** */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[Duration|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "2": "fred"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* string ** xju.time.Duration **|string ** bool ** */]: number }} because Error: element 2 is invalid because Error: fred is not a number it is a string");
    }}
    try{{
        {indent(8,codec(dict[Duration|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "ann": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* string ** xju.time.Duration **|string ** bool ** */]: number }} because Error: element ann is invalid because Error: ann is not a string /* string ** xju.time.Duration **|string ** bool ** */ because Error: key ann is not a stringified number and ann is not 'true' or 'false'");
    }}

    assert_true({indent(8,codec(dict[Duration|bool,int]).get_typescript_isa(TypeScriptSourceCode('{"1": 8, "true": 9}'),namespace))});
    assert_false({indent(8,codec(dict[Duration|bool,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[Duration|bool,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}})();
''')

print(f'''
//dict[Timestamp|bool,T]
(() => {{
    assert_equal({indent(8,codec(dict[Timestamp|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1.2": 8, "true": 9}'),namespace))}, {{"1.2": 8, "true":9}});
    try{{
        {indent(8,codec(dict[Timestamp|bool,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* string ** xju.time.Timestamp **|string ** bool ** */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[Timestamp|bool,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* string ** xju.time.Timestamp **|string ** bool ** */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[Timestamp|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "2": "fred"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* string ** xju.time.Timestamp **|string ** bool ** */]: number }} because Error: element 2 is invalid because Error: fred is not a number it is a string");
    }}
    try{{
        {indent(8,codec(dict[Timestamp|bool,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "ann": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* string ** xju.time.Timestamp **|string ** bool ** */]: number }} because Error: element ann is invalid because Error: ann is not a string /* string ** xju.time.Timestamp **|string ** bool ** */ because Error: xju.time.Timesamp key ann is not a stringified number and ann is not 'true' or 'false'");
    }}

    assert_true({indent(8,codec(dict[Timestamp|bool,int]).get_typescript_isa(TypeScriptSourceCode('{"1": 8, "true": 9}'),namespace))});
    assert_false({indent(8,codec(dict[Timestamp|bool,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[Timestamp|bool,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}})();
''')

print(f'''
//dict[Literal[10]|Literal[True],T]
(() => {{
    assert_equal({indent(8,ten_codec.get_typescript_asa(TypeScriptSourceCode('{"10": 8, "true": 9}'),namespace))}, {{"10": 8, "true":9}});
    try{{
        {indent(8,ten_codec.get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* '10'|'true' */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,ten_codec.get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* '10'|'true' */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,ten_codec.get_typescript_asa(TypeScriptSourceCode('{"1":8, "2": "fred"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* '10'|'true' */]: number }} because Error: element 1 is invalid because Error: 1 is not a string /* '10'|'true' */ because Error: (string) 1 is not the stringified number 10 and (string) 1 is not 'true'");
    }}
    try{{
        {indent(8,ten_codec.get_typescript_asa(TypeScriptSourceCode('{"1":8, "ann": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* '10'|'true' */]: number }} because Error: element 1 is invalid because Error: 1 is not a string /* '10'|'true' */ because Error: (string) 1 is not the stringified number 10 and (string) 1 is not 'true'");
    }}

    assert_true({indent(8,ten_codec.get_typescript_isa(TypeScriptSourceCode('{"10": 8, "true": 9}'),namespace))});
    assert_false({indent(8,ten_codec.get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,ten_codec.get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}})();
''')

print(f'''
//dict[Literal["j ock"]|Literal[O.a]|Surname,T]
const test_aaaa=() => {{
    assert_equal({indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_asa(TypeScriptSourceCode('{"j ock": 8, "Jones": 9, "fred": 15}'),namespace))}, {{"j ock": 8, "Jones":9, "fred": 15}});
    try{{
        {indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* j ock|O.a|string ** Surname ** */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* j ock|O.a|string ** Surname ** */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_asa(TypeScriptSourceCode('{"1":8, "2": "jack"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* j ock|O.a|string ** Surname ** */]: number }} because Error: element 2 is invalid because Error: jack is not a number it is a string");
    }}
    try{{
        {indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_asa(TypeScriptSourceCode('{"1 s":8, "ann s": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* j ock|O.a|string ** Surname ** */]: number }} because Error: element 1 s is invalid because Error: 1 s is not a string /* j ock|O.a|string ** Surname ** */ because Error: (string) 1 s is not the string j ock and the string 1 s is not O.a and 1 s does not match pattern ^\\\\S*$");
    }}

    assert_true({indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_isa(TypeScriptSourceCode('{"1": 8, "true": 9}'),namespace))});
    assert_false({indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[Literal["j ock"]|Literal[O.a]|Surname,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}};
''')

print(f'''
//dict[Pnum,T]
const test_bbbb=() => {{
    assert_equal({indent(8,codec(dict[Pnum,int]).get_typescript_asa(TypeScriptSourceCode('{"bb": 8, "aa": 15}'),namespace))}, {{"bb": 8,"aa": 15}});
    try{{
        {indent(8,codec(dict[Pnum,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* Pnum */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[Pnum,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* Pnum */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[Pnum,int]).get_typescript_asa(TypeScriptSourceCode('{"bb":8, "aa": "jock"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* Pnum */]: number }} because Error: element aa is invalid because Error: jock is not a number it is a string");
    }}
    try{{
        {indent(8,codec(dict[Pnum,int]).get_typescript_asa(TypeScriptSourceCode('{"aa":8, "ann": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* Pnum */]: number }} because Error: element ann is invalid because Error: ann is not a string /* Pnum */ key because Error: the string ann is not Pnum.a and the string ann is not Pnum.b");
    }}

    assert_true({indent(8,codec(dict[Pnum,int]).get_typescript_isa(TypeScriptSourceCode('{"bb": 8, "aa": 9}'),namespace))});
    assert_false({indent(8,codec(dict[Pnum,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[Pnum,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}};
''')

print(f'''
//dict[IpV4Addr,T]
const test_bbbb2=() => {{
    assert_equal({indent(8,codec(dict[IpV4Addr,int]).get_typescript_asa(TypeScriptSourceCode('{"123456": 8}'),namespace))}, {{"123456": 8}});
    try{{
        {indent(8,codec(dict[IpV4Addr,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* int ** IpV4Addr ** */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[IpV4Addr,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* int ** IpV4Addr ** */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[IpV4Addr,int]).get_typescript_asa(TypeScriptSourceCode('{"bb":8, "aa": "jock"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* int ** IpV4Addr ** */]: number }} because Error: element bb is invalid because Error: bb is not a stringified integer");
    }}
    try{{
        {indent(8,codec(dict[IpV4Addr,int]).get_typescript_asa(TypeScriptSourceCode('{"aa":8, "ann": 9}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* int ** IpV4Addr ** */]: number }} because Error: element aa is invalid because Error: aa is not a stringified integer");
    }}

    assert_true({indent(8,codec(dict[IpV4Addr,int]).get_typescript_isa(TypeScriptSourceCode('{"123456": 8}'),namespace))});
    assert_false({indent(8,codec(dict[IpV4Addr,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[IpV4Addr,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}};
''')

print(f'''
//dict[IpV4AddrWithPrefix,T]
const test_bbbb3=() => {{
    assert_equal({indent(8,codec(dict[IpV4AddrWithPrefix,int]).get_typescript_asa(TypeScriptSourceCode('{"172.1.1.2/16": 8}'),namespace))}, {{"172.1.1.2/16": 8}});
    try{{
        {indent(8,codec(dict[IpV4AddrWithPrefix,int]).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string /* string ** IpV4AddrWithPrefix ** */]: number }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict[IpV4AddrWithPrefix,int]).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string /* string ** IpV4AddrWithPrefix ** */]: number }} because Error: 7,ann is not an object it is an array");
    }}
    try{{
        {indent(8,codec(dict[IpV4AddrWithPrefix,int]).get_typescript_asa(TypeScriptSourceCode('{"bb":8, "aa": "jock"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a {{ [key: string /* string ** IpV4AddrWithPrefix ** */]: number }} because Error: element aa is invalid because Error: jock is not a number it is a string");
    }}

    assert_true({indent(8,codec(dict[IpV4AddrWithPrefix,int]).get_typescript_isa(TypeScriptSourceCode('{"172.1.1.2/16": 8}'),namespace))});
    assert_false({indent(8,codec(dict[IpV4AddrWithPrefix,int]).get_typescript_isa(TypeScriptSourceCode('null'),namespace))});
    assert_false({indent(8,codec(dict[IpV4AddrWithPrefix,int]).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace))});
}};
''')

print(f'''
//dict
(() => {{
    assert_equal({indent(4,codec(dict).get_typescript_asa(TypeScriptSourceCode('{"fred": 8}'),namespace))}, {{"fred": 8}});
    assert_equal({indent(4,codec(dict).get_typescript_asa(TypeScriptSourceCode('{"fred": 8, "ann": "low"}'),namespace))}, {{"fred": 8, "ann": "low"}});
    try{{
        {indent(8,codec(dict).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a {{ [key: string]: any }} because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(dict).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a {{ [key: string]: any }} because Error: 7,ann is not an object it is an array");
    }}
    assert_true({codec(dict).get_typescript_isa(TypeScriptSourceCode('{"fred": 8}'),namespace)});
    assert_false({codec(dict).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
    assert_false({codec(dict).get_typescript_isa(TypeScriptSourceCode('null'),namespace)});
}})();
''')

print(f'''
//NewInt
(() => {{
    assert_equal({indent(4,codec(ByteCount).get_typescript_asa(TypeScriptSourceCode('8'),namespace))}, 8);
    try{{
        {indent(8,codec(ByteCount).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a xju.misc.ByteCount i.e. a number, it is a object");
    }}
    assert_true({codec(ByteCount).get_typescript_isa(TypeScriptSourceCode('8'),namespace)});
    assert_false({codec(ByteCount).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')

print(f'''
//NewFloat
(() => {{
    assert_equal({indent(4,codec(Duration).get_typescript_asa(TypeScriptSourceCode('8.8'),namespace))}, 8.8);
    try{{
        {indent(8,codec(Duration).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a xju.time.Duration i.e. a number, it is a object");
    }}
    assert_true({codec(Duration).get_typescript_isa(TypeScriptSourceCode('8.8'),namespace)});
    assert_false({codec(Duration).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')

print(f'''
//NewStr
(() => {{
    assert_equal({indent(4,codec(TypeScriptSourceCode).get_typescript_asa(TypeScriptSourceCode('"int"'),namespace))}, "int");
    try{{
        {indent(8,codec(TypeScriptSourceCode).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a xju.json_codec.TypeScriptSourceCode i.e. a string, it is a object");
    }}
    assert_true({codec(TypeScriptSourceCode).get_typescript_isa(TypeScriptSourceCode('"int"'),namespace)});
    assert_false({codec(TypeScriptSourceCode).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')

fred_codec=codec(Literal['fred'])
print(f'''
//Literal['fred']
(() => {{
    assert_equal({indent(4,fred_codec.get_typescript_asa(TypeScriptSourceCode('"fred"'),namespace))}, "fred");
    try{{
        {indent(8,fred_codec.get_typescript_asa(TypeScriptSourceCode('"ann"'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (string) ann is not the string fred');
    }}
    try{{
        {indent(8,fred_codec.get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (object) 7,ann is not the string fred');
    }}
    assert_true({fred_codec.get_typescript_isa(TypeScriptSourceCode('"fred"'),namespace)});
    assert_false({fred_codec.get_typescript_isa(TypeScriptSourceCode('"jock"'),namespace)});
    assert_false({fred_codec.get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')

seven_codec=codec(Literal[7])
print(f'''
//Literal[7]
(() => {{
    assert_equal({indent(4,seven_codec.get_typescript_asa(TypeScriptSourceCode('7'),namespace))}, 7);
    try{{
        {indent(8,seven_codec.get_typescript_asa(TypeScriptSourceCode('10'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (number) 10 is not the number 7');
    }}
    try{{
        {indent(8,seven_codec.get_typescript_asa(TypeScriptSourceCode('[7,10]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (object) 7,10 is not the number 7');
    }}
    assert_true({seven_codec.get_typescript_isa(TypeScriptSourceCode('7'),namespace)});
    assert_false({seven_codec.get_typescript_isa(TypeScriptSourceCode('"jock"'),namespace)});
    assert_false({seven_codec.get_typescript_isa(TypeScriptSourceCode('[7, 10]'),namespace)});
}})();
''')

true_codec=codec(Literal[True])
print(f'''
//Literal[True]
(() => {{
    assert_equal({indent(4,true_codec.get_typescript_asa(TypeScriptSourceCode('true'),namespace))}, true);
    try{{
        {indent(8,true_codec.get_typescript_asa(TypeScriptSourceCode('10'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (number) 10 is not true');
    }}
    try{{
        {indent(8,true_codec.get_typescript_asa(TypeScriptSourceCode('[7,10]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (object) 7,10 is not true');
    }}
    assert_true({true_codec.get_typescript_isa(TypeScriptSourceCode('true'),namespace)});
    assert_false({true_codec.get_typescript_isa(TypeScriptSourceCode('"jock"'),namespace)});
    assert_false({true_codec.get_typescript_isa(TypeScriptSourceCode('[7, 10]'),namespace)});
}})();
''')

fred_7_False_codec=codec(Literal['fred', 7, False])
print(f'''
//Literal['fred']
(() => {{
    assert_equal({indent(4,fred_7_False_codec.get_typescript_asa(TypeScriptSourceCode('"fred"'),namespace))}, "fred");
    assert_equal({indent(4,fred_7_False_codec.get_typescript_asa(TypeScriptSourceCode('7'),namespace))}, 7);
    assert_equal({indent(4,fred_7_False_codec.get_typescript_asa(TypeScriptSourceCode('false'),namespace))}, false);
    try{{
        {indent(8,fred_7_False_codec.get_typescript_asa(TypeScriptSourceCode('"ann"'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (string) ann is not the string fred');
    }}
    try{{
        {indent(8,fred_7_False_codec.get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), 'Error: (object) 7,ann is not the string fred');
    }}
    assert_true({fred_7_False_codec.get_typescript_isa(TypeScriptSourceCode('"fred"'),namespace)});
    assert_false({fred_7_False_codec.get_typescript_isa(TypeScriptSourceCode('"jock"'),namespace)});
    assert_false({fred_7_False_codec.get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')

print(f'''
//class
// FullName
(() => {{
    assert_equal({indent(4,codec(FullName).get_typescript_asa(TypeScriptSourceCode('{first_name: "fred", middle_names: [], last_name: "flak", class: "Middle"}'),namespace))}, {{first_name: "fred", middle_names: [], last_name: "flak", class: "Middle"}});
    try{{
        {indent(8,codec(FullName).get_typescript_asa(TypeScriptSourceCode('null'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: null is not a FullName because Error: null is not an object it is null");
    }}
    try{{
        {indent(8,codec(FullName).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a FullName because Error: 7,ann is an array");
    }}
    try{{
        {indent(8,codec(FullName).get_typescript_asa(TypeScriptSourceCode('"fred"'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: fred is not a FullName because Error: fred is not an object it is a string");
    }}
    try{{
        {indent(8,codec(FullName).get_typescript_asa(TypeScriptSourceCode('{first_name: "fred", last_name: "flak", class: "Middle"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a FullName because Error: attribute middle_names is invalid because Error: undefined is not a Array<string> because Error: undefined is not an array it is a undefined");
    }}
    try{{
        {indent(8,codec(FullName).get_typescript_asa(TypeScriptSourceCode('{first_name: "fred", middle_names: "joan", last_name: "flak", class: "Middle"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a FullName because Error: attribute middle_names is invalid because Error: joan is not a Array<string> because Error: joan is not an array it is a string");
    }}
    assert_true({codec(FullName).get_typescript_isa(TypeScriptSourceCode('{first_name: "fred", middle_names: [], last_name: "flak", class: "Middle"}'),namespace)});
    assert_true({codec(FullName).get_typescript_isa(TypeScriptSourceCode('{first_name: "fred", middle_names: ["joan"], last_name: "flak", class: "Middle"}'),namespace)});
    assert_true({codec(FullName).get_typescript_isa(TypeScriptSourceCode('{first_name: "fred", middle_names: ["joan"], last_name: "flak", class: "Middle", age: 10}'),namespace)});
    assert_false({codec(FullName).get_typescript_isa(TypeScriptSourceCode('null'),namespace)});
    assert_false({codec(FullName).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
//Prefs
(() => {{
    assert_equal({indent(4,codec(Prefs).get_typescript_asa(TypeScriptSourceCode('{colours: ["red", "blue"]}'),namespace))}, {{colours: ["red", "blue"]}});
    try{{
        {indent(8,codec(Prefs).get_typescript_asa(TypeScriptSourceCode('{colours: [7, "blue"]}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a Prefs because Error: attribute colours is invalid because Error: 7,blue is not a Array<string> /* with unique elements */ because Error: 7 is not a string it is a number");
    }}
    assert_true({codec(Prefs).get_typescript_isa(TypeScriptSourceCode('{colours: ["red", "blue"]}'),namespace)});
    assert_false({codec(Prefs).get_typescript_isa(TypeScriptSourceCode('null'),namespace)});
    assert_false({codec(Prefs).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')


print(f'''
//recursive type
(() => {{
    assert_equal('{namespace_codec.typescript_type()}','xju.json_codec.TypeScriptNamespace');
    assert_equal({indent(4,namespace_codec.get_typescript_asa(TypeScriptSourceCode('{defs:{x:"Fred",y:{defs:{y:"Jock"}}}}'),namespace))}, {{defs:{{x:"Fred",y:{{defs:{{y:"Jock"}}}}}}}});
    try{{
        {indent(8,namespace_codec.get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a xju.json_codec.TypeScriptNamespace because Error: 7,ann is an array");
    }}
    try{{
        {indent(8,namespace_codec.get_typescript_asa(TypeScriptSourceCode('"fred"'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: fred is not a xju.json_codec.TypeScriptNamespace because Error: fred is not an object it is a string");
    }}
    try{{
        {indent(8,namespace_codec.get_typescript_asa(TypeScriptSourceCode('{first_name: "fred", last_name: "flak"}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a xju.json_codec.TypeScriptNamespace because Error: attribute defs is invalid because Error: undefined is not a {{ [key: string /* xju.json_codec.TypeScriptUQN */]: xju.json_codec.TypeScriptSourceCode|xju.json_codec.TypeScriptNamespace }} because Error: undefined is not an object it is a undefined");
    }}
    try{{
        {indent(8,namespace_codec.get_typescript_asa(TypeScriptSourceCode('{defs:{x:"Fred",y:{defs:{y:7}}}}'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: [object Object] is not a xju.json_codec.TypeScriptNamespace because Error: attribute defs is invalid because Error: [object Object] is not a {{ [key: string /* xju.json_codec.TypeScriptUQN */]: xju.json_codec.TypeScriptSourceCode|xju.json_codec.TypeScriptNamespace }} because Error: element y is invalid because Error: [object Object] is not a xju.json_codec.TypeScriptSourceCode|xju.json_codec.TypeScriptNamespace because Error: [object Object] is not a xju.json_codec.TypeScriptSourceCode i.e. a string, it is a object and [object Object] is not a xju.json_codec.TypeScriptNamespace because Error: attribute defs is invalid because Error: [object Object] is not a {{ [key: string /* xju.json_codec.TypeScriptUQN */]: xju.json_codec.TypeScriptSourceCode|xju.json_codec.TypeScriptNamespace }} because Error: element y is invalid because Error: 7 is not a xju.json_codec.TypeScriptSourceCode|xju.json_codec.TypeScriptNamespace because Error: 7 is not a xju.json_codec.TypeScriptSourceCode i.e. a string, it is a number and 7 is not a xju.json_codec.TypeScriptNamespace because Error: 7 is not an object it is a number");
    }}
    const x:object={{defs:{{x:"Fred",y:{{defs:{{z:"Jock"}}}}}}}};
    if ({indent(8,namespace_codec.get_typescript_isa(TypeScriptSourceCode('x'),namespace))}) {{
        if ({indent(8,namespace_codec.get_typescript_isa(TypeScriptSourceCode('x.defs.y'),namespace))}){{
            assert_equal(x.defs.y.defs.z, "Jock");
        }}
        else{{
            throw new Error('should not be here');
        }}
    }}
    else{{
        throw new Error('should not be here');
    }}
    assert_false({namespace_codec.get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')

print(f'''
//alias
(() => {{
    var x:any = 8.8;
    var y:number|string = xju.asInstanceOfNorS(x);
    if (typeof y !== 'number') {{
        throw new Error(`typeof y is ${{typeof y}} not number`);
    }}
    assert_equal(y, 8.8);
    if (!xju.isInstanceOfNorS(x)) {{
        throw new Error(`${{y}} (of type ${{typeof y}}) is not a NorS`);
    }}
    assert_equal(x, 8.8);
}})();
//NewInt alias
(() => {{
    var x:any = 8;
    var y:xju.misc.ByteCount = xju.misc.asInstanceOfByteCount(x);
    assert_equal(y, 8);
    if (!xju.misc.isInstanceOfByteCount(x)) {{
        throw new Error(`${{y}} (of type ${{typeof y}}) is not a xju.misc.ByteCount`);
    }}
    assert_equal(x, 8);
}})();
//NewFloat alias
(() => {{
    var x:any = 8.8;
    var y:xju.time.Duration = xju.time.asInstanceOfDuration(x);
    assert_equal(y, 8.8);
    if (!xju.time.isInstanceOfDuration(x)) {{
        throw new Error(`${{y}} (of type ${{typeof y}}) is not a xju.time.Duration`);
    }}
    assert_equal(x, 8.8);
}})();
//NewStr alias
(() => {{
    var x:any = "fred";
    var y:xju.json_codec.TypeScriptUQN = xju.json_codec.asInstanceOfTypeScriptUQN(x);
    assert_equal(y, "fred");
    if (!xju.json_codec.isInstanceOfTypeScriptUQN(x)) {{
        throw new Error(`${{y}} (of type ${{typeof y}}) is not a xju.json_codec.TypeScriptUQN`);
    }}
    assert_equal(x, "fred");
}})();
''')

print(f'''
//enum
(() => {{
    var x:any = "fred";
    var y:O = asInstanceOfO(x);
    if (y !== "fred") {{
        throw new Error(`${{y}} is not "fred"`);
    }}
    if (!isInstanceOfO(x)) {{
        throw new Error(`${{x}} (of type ${{typeof x}}) is not a O`);
    }}
    x = 9;
    try{{
        y = asInstanceOfO(x);
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 9 is not a O because Error: the number 9 is not O.a and the number 9 is not O.b");
    }}
    if (isInstanceOfO(x)) {{
        throw new Error(`${{x}} (of type ${{typeof x}}) is (unexpectedly) a O`);
    }}
}})();
''')

print(f'''
//xju.newstype.Str with pattern
(() => {{
    var x:any = "fred";
    var y:Surname = asInstanceOfSurname(x);
    if (y !== "fred") {{
        throw new Error(`${{y}} is not "fred"`);
    }}
    if (!isInstanceOfSurname(x)) {{
        throw new Error(`${{x}} (of type ${{typeof x}}) is not a Surnamee`);
    }}
    x = 9;
    try{{
        y = asInstanceOfSurname(x);
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 9 is not a Surname i.e. a string, it is a number");
    }}
    if (isInstanceOfSurname(x)) {{
        throw new Error(`${{x}} (of type ${{typeof x}}) is (unexpectedly) a O`);
    }}
    x = "St. Cloud";
    try{{
        y = asInstanceOfSurname(x);
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: St. Cloud does not match pattern ^\\\\S*$");
    }}
    if (isInstanceOfSurname(x)) {{
        throw new Error(`${{x}} (of type ${{typeof x}}) is (unexpectedly) a O`);
    }}
}})();
''')

print(f'''
//Timestamp
(() => {{
    assert_equal({indent(4,codec(Timestamp).get_typescript_asa(TypeScriptSourceCode('8.8'),namespace))}, 8.8);
    try{{
        {indent(8,codec(Timestamp).get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: 7,ann is not a xju.time.Timestamp i.e. a number, it is a object");
    }}
    assert_true({codec(Timestamp).get_typescript_isa(TypeScriptSourceCode('8.8'),namespace)});
    assert_false({codec(Timestamp).get_typescript_isa(TypeScriptSourceCode('[7, "ann"]'),namespace)});
}})();
''')

o_a_codec=codec(O.a) # type: ignore
print(f'''
//Enum value
(() => {{
    assert_equal({indent(4,o_a_codec.get_typescript_asa(TypeScriptSourceCode("'fred'"),namespace))}, 'fred');
    try{{
        {indent(8,o_a_codec.get_typescript_asa(TypeScriptSourceCode('[7,"ann"]'),namespace))};
        assert_never_reached();
    }}
    catch(e){{
        assert_x_contains_y(str(e), "Error: the object 7,ann is not O.a");
    }}
    assert_true({o_a_codec.get_typescript_isa(TypeScriptSourceCode("'fred'"),namespace)});
    var v="jock";
    assert_false({o_a_codec.get_typescript_isa(TypeScriptSourceCode("v"),namespace)});
}})();
''')


try:
    codec(int|str).add_typescript_alias(namespace, [TypeScriptUQN('xju'),TypeScriptUQN('NorS')])
except Exception as e:
    Assert(readable_repr(e)).contains('is already defined')
else:
    assert False
    pass

Assert(codec(int).typescript_as_object_key_type())==TypeScriptSourceCode("string /* int */")
Assert(codec(float).typescript_as_object_key_type())==TypeScriptSourceCode("string /* float */")
Assert(codec(bool).typescript_as_object_key_type())==TypeScriptSourceCode("string /* bool */")
Assert(codec(NoneType).typescript_as_object_key_type())==TypeScriptSourceCode("string /* null */")

try:
    codec(list[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[bool]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='[boolean] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[str,str]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: string } is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(ByteCount).typescript_as_object_key_type())==TypeScriptSourceCode('string /* xju.misc.ByteCount */')
Assert(codec(Duration).typescript_as_object_key_type())==TypeScriptSourceCode('string /* xju.time.Duration */')

Assert(codec(Timestamp).typescript_as_object_key_type())==TypeScriptSourceCode(
    "string /* xju.time.Timestamp */")

try:
    codec(NonStringKey).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='NonStringKey is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(O).typescript_as_object_key_type())==TypeScriptSourceCode("string /* O */")

try:
    AnyJsonCodecImpl().typescript_as_object_key_type(None)
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass
    
try:
    codec(FullName).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass
    
try:
    codec(bytes).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass
    
@dataclass
class Selfish:
    value: int
    next: dict[int, Self]
    pass

try:
    codec(Selfish).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

back_refs=TypeScriptBackRefs(
    type_back_ref=lambda: TypeScriptSourceCode("fred"),
    as_object_key_type_back_ref=lambda: TypeScriptSourceCode("jock"),
    isa_back_ref=lambda x: TypeScriptSourceCode("ann"),
    asa_back_ref=lambda x: TypeScriptSourceCode("polly")
)

try:
    SelfCodecImpl().get_typescript_isa_key(TypeScriptSourceCode('k'),namespace,back_refs)
except Exception as e:
    Assert(readable_repr(e))=='fred is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    SelfCodecImpl().get_typescript_asa_key(TypeScriptSourceCode('k'),namespace,back_refs)
except Exception as e:
    Assert(readable_repr(e))=='fred is not allowed as a typescript object key type'
else:
    assert False
    pass

codec(Selfish).ensure_typescript_defs(namespace)

try:
    codec(list[int]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(dict[ByteCount,str]).decode({'38':'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[ByteCount,str]).decode({38:'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[ByteCount,str]).encode({ByteCount(38):'fred'}))=={38:'fred'}

Assert(codec(dict[bool|ByteCount,str]).decode({'38':'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({38:'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[bool|ByteCount,str]).encode({ByteCount(38):'fred'}))=={38:'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({'true':'fred'}))=={True:'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({True:'fred'}))=={True:'fred'}
Assert(codec(dict[bool|ByteCount,str]).encode({True:'fred'}))=={True:'fred'}

Assert(codec(dict[Surname|str,str]).decode({'Jones':'fred'}))=={Surname('Jones'):'fred'}
Assert(codec(dict[Surname|str,str]).decode({'Mc Sweeney':'fred'}))=={'Mc Sweeney':'fred'}
Assert(codec(dict[Surname|str,str]).encode({Surname('Jones'):'fred'}))=={'Jones':'fred'}

Assert(codec(dict[Surname,str]).decode({'Jones':'fred'}))=={Surname('Jones'):'fred'}
Assert(codec(dict[Surname,str]).encode({Surname('Jones'):'fred'}))=={'Jones':'fred'}

c=codec(dict[int|bool,float])
try:
    c.decode({'fred':8.2})
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode {'fred': 8.2} to a dict[int | bool, float] because\n- failed to decode key 'fred' via json.loads because\n  Expecting value: line 1 column 1 (char 0); and\n- failed to decode key 'fred' directly because\n  failed to decode 'fred' as one of (<class 'int'>, <class 'bool'>) because\n  - failed to decode as <class 'int'> because\n    'fred' (of type <class 'str'>) is not a <class 'int'>; and\n  - failed to decode as <class 'bool'> because\n    'fred' (of type <class 'str'>) is not a <class 'bool'>."
else:
    assert False
    pass

try:
    codec(dict[dict[int,bool],str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string /* int */]: boolean } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[JsonType,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=="Failed to get typescript type of dictionary key that is any of (<class 'NoneType'>, <class 'bool'>, <class 'dict'>, <class 'list'>, <class 'float'>, <class 'str'>) because\n{ [key: string]: any } is not allowed as a typescript object key type."
else:
    assert False
    pass

try:
    codec(bytes).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(JsonType).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list[int]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict[int,bool],str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string /* int */]: boolean } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    AnyJsonCodecImpl().get_typescript_isa_key(TypeScriptSourceCode('k'),namespace,None)
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(bytes).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    AnyJsonCodecImpl().get_typescript_asa_key(TypeScriptSourceCode('k'),namespace,None)
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(FullName).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(FullName).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[list[int],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("list is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[list,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("list is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[set[str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("set is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[set,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("set is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[tuple[int,str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("tuple is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[dict[int,str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("dict is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("dict is not allowed as json object key type")
else:
    assert False
    pass

try:
    # unreachable via codec()
    AnyJsonCodecImpl().get_object_key_json_schema({},None)
except Exception as e:
    Assert(readable_repr(e)).contains("any json type is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[bytes,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("bytes is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[FullName,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("FullName is not allowed as json object key type")
else:
    assert False
    pass

try:
    # unreachable via codec()
    SelfCodecImpl().get_object_key_json_schema({},None)
except Exception as e:
    Assert(readable_repr(e)).contains("Self is not allowed as json object key type")
else:
    assert False
    pass

print('''
test_aaaa();
test_bbbb();
test_bbbb2();
test_bbbb3();
''')
